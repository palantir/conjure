test-case-name: "services"
positive:
  emptyServicesOK:
    conjure:
      services:
          # valid: empty services OK
  samePathOKWithUniqueMethods:
    conjure:
      services:
        TestService:
          name: Test Service
          package: test.a
          endpoints:
            # valid: multiple endpoints can have the same path if method is unique
            testEndpoint:
              http: GET /myEndpoint
            otherTestEndpoint:
              http: DELETE /myEndpoint
  allowPrimitivesInPathParams:
    conjure:
      services:
        Unused:
          name: Unused
          package: unused
          endpoints:
            string:
              http: GET /string/{foo}
              args:
                foo: string
            integer:
              http: GET /integer/{foo}
              args:
                foo: integer
            double:
              http: GET /double/{foo}
              args:
                foo: double
            boolean:
              http: GET /boolean/{foo}
              args:
                foo: boolean
            safelong:
              http: GET /safelong/{foo}
              args:
                foo: safelong
            rid:
              http: GET /rid/{foo}
              args:
                foo: rid
  allowDateTimeInPathParams:
    conjure:
      services:
        Unused:
          name: Unused
          package: unused
          endpoints:
            unused:
              http: GET /{foo}
              args: { foo: datetime }
  allowEnumPathParam:
    conjure:
      types:
        definitions:
          default-package: foo
          objects:
            MyEnum:
              values:
                - FOO
                - BAR
      services:
        Unused:
          name: Unused
          package: unused
          endpoints:
            unused:
              http: GET /{foo}
              args: { foo: MyEnum }
  allowAliasAliasEnumPathParam:
    conjure:
      types:
        definitions:
          default-package: foo
          objects:
            Alias1:
              alias: Alias2
            Alias2:
              alias: MyEnum
            MyEnum:
              values:
              - FOO
              - BAR
      services:
        Unused:
          name: Unused
          package: unused
          endpoints:
            unused:
              http: GET /{foo}
              args: { foo: Alias1 }
  allowAliasIntegerHeaderParam:
    conjure:
      types:
        definitions:
          default-package: foo
          objects:
            Alias1:
              alias: integer
      services:
        Unused:
          name: Unused
          package: unused
          endpoints:
            unused:
              http: GET /foo
              args:
                foo:
                  type: Alias1
                  param-type: header
                  param-id: Bar
  allowOptionalAliasStringHeaderParam:
    conjure:
      types:
        definitions:
          default-package: foo
          objects:
            Alias1:
              alias: string
      services:
        Unused:
          name: Unused
          package: unused
          endpoints:
            unused:
              http: GET /foo
              args:
                foo:
                  type: optional<Alias1>
                  param-type: header
                  param-id: Bar
  allowImportAsQueryParam:
    conjure:
      types:
        imports:
          Long:
            base-type: string
            external:
              java: java.lang.Long
      services:
        Unused:
          name: Unused
          package: unused
          endpoints:
            unused:
              http: GET /foo
              args:
                bar:
                  type: Long
                  param-type: query
  allowImportAsPathParam:
    conjure:
      types:
        imports:
          Long:
            base-type: string
            external:
              java: java.lang.Long
      services:
        Unused:
          name: Unused
          package: unused
          endpoints:
            unused:
              http: GET /foo/{baz}
              args:
                baz:
                  type: Long
                  param-type: path

negative:
  disallowBearerTokenInPathParams:
    expected-error: "Path or query parameters of type 'bearertoken' are not allowed as this would introduce a security vulnerability: \"foo\""
    conjure:
      services:
        Unused:
          name: Unused
          package: unused
          endpoints:
            unused:
              http: GET /{foo}
              args:
                foo: bearertoken
  disallowBearerTokenInQueryParams:
    expected-error: "Path or query parameters of type 'bearertoken' are not allowed as this would introduce a security vulnerability: \"foo\""
    conjure:
      services:
        Unused:
          name: Unused
          package: unused
          endpoints:
            unused:
              http: GET /foo
              args:
                foo:
                  type: bearertoken
                  param-type: query
  disallowAnyInPathParams:
    expected-error: 'Path parameters must be primitives or aliases: "foo" is not allowed'
    conjure:
      services:
        Unused:
          name: Unused
          package: unused
          endpoints:
            unused:
              http: GET /{foo}
              args:
                foo: any
  disallowListInPathParams:
    expected-error: 'Path parameters must be primitives or aliases: "foo" is not allowed'
    conjure:
      services:
        Unused:
          name: Unused
          package: unused
          endpoints:
            unused:
              http: GET /{foo}
              args:
                foo: list<string>
  disallowMapInPathParams:
    expected-error: 'Path parameters must be primitives or aliases: "foo" is not allowed'
    conjure:
      services:
        Unused:
          name: Unused
          package: unused
          endpoints:
            unused:
              http: GET /{foo}
              args:
                foo: map<string, string>
  disallowOptionalInPathParams:
    expected-error: 'Path parameters must be primitives or aliases: "foo" is not allowed'
    conjure:
      services:
        Unused:
          name: Unused
          package: unused
          endpoints:
            unused:
              http: GET /{foo}
              args:
                foo: optional<string>
  disallowSetInPathParams:
    expected-error: 'Path parameters must be primitives or aliases: "foo" is not allowed'
    conjure:
      services:
        Unused:
          name: Unused
          package: unused
          endpoints:
            unused:
              http: GET /{foo}
              args:
                foo: set<string>
  endpointPathMethodMustBeUnique:
    expected-error: 'Endpoint "GET /myEndpoint" is defined by multiple endpoints: [testEndpoint, otherTestEndpoint]'
    conjure:
      services:
        TestService:
          name: Test Service
          package: test.a
          endpoints:
            # valid: cannot have multiple endpoints with the same method and path
            testEndpoint:
              http: GET /myEndpoint
            otherTestEndpoint:
              http: GET /myEndpoint
  endpointReturnsWithNestedOptional:
    expected-error: "Illegal nested optionals found in return type of endpoint testEndpoint"
    conjure:
      services:
        TestService:
          name: Test Service
          package: test.a
          endpoints:
            testEndpoint:
              http: GET /myEndpoint
              returns: optional<optional<string>>
  endpointQueryParamWithNestedOptional:
      expected-error: "Illegal nested optionals found in one of the arguments of endpoint testEndpoint"
      conjure:
        services:
          TestService:
            name: Test Service
            package: test.a
            endpoints:
              testEndpoint:
                http: GET /myEndpoint
                args:
                  queryName:
                    type: optional<optional<string>>
                    param-type: query
